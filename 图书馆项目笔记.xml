<?xml version="1.0" encoding="UTF-8"?>
<Document>
	<project_note>
		<git_note id="01">
			<title>git使用方法</title>
			<body>
				windows 系统修改git commit 最后一次提交的注释信息以及如何退出git bash vim编辑器
				今天用git commit -m &quot;注释&quot;提交的时候，注释写错了
				首先 使用 git commit --amend 命令，（修改最近一次提交的注释信息），会进入到vim 编辑器
				然后 你会发现编辑器里你怎么输入都没反应，这是因为vim处在不可编辑状态，按下字母键 c，此时进入编辑状态，可以开始修改注释信息了
				在然后 你会发现你怎么都退出不了，回到shell了，然后操作如下： ESC  --> 退出编辑状态；接着 连续按两次大写字母键 Z，接着你会惊喜的发现，终于保存好退出来了！
				$ git branch
				$ git add .
				$ git commit -m &quot;2018/12/25&quot;
				$ git push --set-upstream origin yuey
				推送上去
				拉下来
				$ git pull 更新
				$ git pull 远程主机名 远程分支名:本地分支名	(例：git pull origin master:yuey)
					<src>https://www.yiibai.com/git/git_pull.html</src>
					<title>Git 的origin和master分析(转)</title>
					<src>http://lishicongli.blog.163.com/blog/static/1468259020132125247302/</src>
					<body>
						在clone完成之后，Git 会自动为你将此远程仓库命名为origin（origin只相当于一个别名，运行git remote –v或者查看.git/config可以看到origin的含义）
					</body>
			</body>
			<title>如何将本地项目上传到github</title>
			<src>https://www.jianshu.com/p/551ee14d26d0</src>

			<title>git branch</title>
			<src>https://www.yiibai.com/git/git_branch.html</src>

		</git_note>

		<All_Start id="02">
			<title>在线浏览PDF之PDF.JS （附demo）</title>
			<src>https://yq.aliyun.com/articles/40197</src>

			<title>XHTML 命名空间</title>
			<src>http://www.w3.org/1999/xhtml/</src>

			<title>Jsoup解析html标签</title>
			<src>https://jsoup.org/</src>
			<note>jsoup是一个用于处理真实HTML的Java库。它提供了一个非常方便的API，用于提取和操作数据，
					使用最好的DOM，CSS和类似jquery的方法。jsoup实现WHATWG HTML5规范，并将HTML解析为与
					现代浏览器相同的DOM。
			</note>

			<title>jsoup 提取 html中的所有链接</title>
			<src>https://blog.csdn.net/aixp88/article/details/62917935</src>
			<code>			
				try {
					Document doc = (Document) Jsoup.connect(url).get();
					Elements links = ((Element) doc).select("a[href]");
					for (Element link : links) {
						String linkHref = link.attr("href");
						String linkText = link.text();
						System.out.println(linkText+"-"+linkHref);
					}
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			</code>			
			<title>[Linux] yum和apt-get用法及区别</title>
			<src>https://www.cnblogs.com/garinzhang/p/diff_between_yum_apt-get_in_linux.html</src>
		</All_Start>

		<List_Now_Question>
			<title>关于java spring mvc搭建小程序后台的问题</title>
			<body>
				1、简单的后台登录功能的实现
			</body>
		</List_Now_Question>

		<service>
			<apache_service_note>
				<title>apache和tomcat的区别</title>
				<src>https://blog.csdn.net/coomon2000/article/details/1761643</src>

				<title>Apache httpd.conf配置详解</title>
				<src>https://www.cnblogs.com/langren1992/p/5160912.html</src>
				<body>.
					ServerRoot：服务器的基础目录，一般来说它将包含conf/和logs/子目录，其它配置文件的相对路径即基于此目录。默认为安装目录，不需更改。
						语法：ServerRoot directory-path
						如：　ServerRoot &quot; /usr/local/apache-2.2.6&quot;
						注意，此指令中的路径最后不要加 / 。
					DocumentRoot：设置Web文档根目录。
						语法：DocumentRoot directory-path
						在没有使用类似Alias这样的指令的情况下，服务器会将请求中的URL附加到DocumentRoot后面以构成指向文档的路径。
						如果directory-path不是绝对路径，则被假定为是相对于ServerRoot的路径。
						指定DocumentRoot时不应包括最后的&quot; /&quot; 。
					&lt; Directory&gt; ：&lt; Directory&gt; 和&lt; /Directory&gt; 用于封装一组指令，使之仅对某个目录及其子目录生效。
						语法：&lt;Directory Directory-path&gt;  ... &lt; /Directory&gt;
						Directory-path可以是一个目录的完整路径，或是包含了Unix shell匹配语法的通配符字符串。在通配符字符串中，&quot; ?&quot; 匹配任何单个的字符，&quot; *&quot; 匹配任何字符序列。也可以使
						用&quot; []&quot; 来确定字符范围。在&quot; ~&quot; 字符之后也可以使用正则表达式。
						如果有多个(非正则表达式)&lt; Directory&gt; 配置段符合包含某文档的目录(或其父目录)，那么指令将以短目录优先的规则进行应用，并包含.htaccess文件中的指令。
						正则表达式将在所有普通配置段之后予以考虑。所有的正则表达式将根据它们出现在配置文件中的顺序进行应用。
						&lt; Directory&gt; 指令不可被嵌套使用，也不能出现在&lt; Limit&gt;或&lt; LimitExcept&gt;配置段中。
				</body>
				<title>Apache服务器配置默认首页文件名和网站路径</title>
				<src>https://www.cnblogs.com/xkxk/p/5501845.html</src>
				<title>apache 配置虚拟路径和访问权限</title>
				<src>https://blog.csdn.net/zhanglinlang/article/details/79421018</src>
				<note>这里设置防线权限Allow deny与之后后台服务器端引流处理请求有关</note>
				<title>Apache服务器安装SSL证书</title>
				<src>https://help.aliyun.com/knowledge_detail/95493.html?spm=5176.2020520154.cas.26.45d3afIVafIVeo</src>
				<note>注意文件名要同压缩包内的文件名一样</note>



			</apache_service_note>

			<nginx_note>
			
				<title>Nginx 入门指南</title>
				<src>https://www.w3cschool.cn/nginx/z5j11pds.html</src>
			
				<title>Nginx详解（正向代理、反向代理、负载均衡原理）</title>
				<src>https://blog.csdn.net/tsummerb/article/details/79248015</src>
				<note>
					1、正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚
					来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。
					2、
				</note>
				
				<title>利用 Nginx 做反向代理解决微信小程序业务域名限制问题</title>
					<src>https://blog.csdn.net/xuanjiewu/article/details/79458266</src>
					<src>https://www.jianshu.com/p/47eff6eeec25</src>
					<add_note>
						<src name="taobao/nginx-book">https://github.com/taobao/nginx-book</src>
						<src>http://tengine.taobao.org/</src>
					</add_note>
				<title>模块ngx_http_sub_module</title>
				<body>		
										sub_filter
					ngx_http_sub_module模块是一个过滤器，它修改网站响应内容中的字符串，
					比如你想把响应内容中的‘ttlsa’全部替换成‘运维生存时间’，这个模块已
					经内置在nginx中，但是默认未安装，需要安装需要加上配置参数：--with-http_sub_module
				</body>
				<Nginx_service_note>
					<title>Nginx/Tengine服务器安装SSL证书</title>
					<sr>https://help.aliyun.com/knowledge_detail/95491.html?spm=5176.2020520154.cas.28.45d3afIVafIVeo</sr>
				</Nginx_service_note>
				
				<title>nginx替换网站响应内容（ngx_http_sub_module）</title>	
				<src>http://www.ttlsa.com/linux/nginx-modules-ngx_http_sub_module/</src>
		
				
				<title>windows下nginx的安装及使用方法入门</title>
				<src>https://www.cnblogs.com/saysmy/p/6609796.html</src>
				<body>
					注意不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程 
					在nginx.exe目录，打开命令行工具，用命令 启动/关闭/重启nginx 		 
					start nginx : 启动nginx
					nginx -s reload  ：修改配置后重新加载生效
					nginx -s reopen  ：重新打开日志文件
					nginx -t -c /path/to/nginx.conf 测试nginx配置文件是否正确
					关闭nginx：
					nginx -s stop  :快速停止nginx
					nginx -s quit  ：完整有序的停止nginx
					如果遇到报错：
					bash: nginx: command not found
					有可能是你再linux命令行环境下运行了windows命令，
					如果你之前是允许 nginx -s reload报错， 试下 ./nginx -s reload
					或者 用windows系统自带命令行工具运行		
				</body>
			
				<title>Nginx-linux-ubuntu配置</title>
				<src>http://wiki.ubuntu.org.cn/Nginx</src>		

				<title>Centos6 Nginx安装</title>
				<src>https://www.cnblogs.com/yaoximing/p/6068622.html</src>
				
				<question>
				<title>解决Nginx: [error] open() ＂/usr/local/Nginx/logs/Nginx.pid</title>
				<src>https://www.cnblogs.com/shabake/p/6406745.html</src>
				
				<title>Centos6 Nginx安装</title>
				<src>https://www.cnblogs.com/yaoximing/p/6068622.html</src>
				</question>
			</nginx_note>
			
			<aliyun>
				
				<title>Lamp</title>
				<code>
				
				</code>
			
			</aliyun>
		</service>		
		<docker>	
			<title>Docker docs</title>
			<src>https://docs.docker.com/docker-for-windows/</src>
			
			<note>
				登录账号dockerid
				列出本地镜像：
				>docker images
				
				先查看所有的容器
				>docker ps -a
				
				移除这个“tomcat8080”容器
				>docker rm e3274a72e8d6
			
				<code>
					docker run常用命令解析
					-i :以交互模式运行，一般与-t共同使用。使用这个可以在运行后进入容器内
					-p: 端口映射，格式为：主机(宿主)端口:容器端口
					-t:分配一个伪终端
					--name="nginx2018": 为容器指定一个名称；
					-h "localhost1": 指定容器的hostname；
					-e username="ritchie": 设置环境变量；
					--env-file=[]: 从指定文件读入环境变量；
					--cpuset="0-2" 
					or --cpuset="0,1,2": 绑定容器到指定CPU运行；
					-m :设置容器使用内存最大值；
					--net="bridge": 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；
					--link=[]: 添加链接到另一个容器；
					--expose=[]: 开放一个端口或一组端口；
				</code>			
			
			<title>docker安装_进入容器修改nginx.conf配置文件_宿主主机挂载（nginx举例）</title>
			<src>https://blog.csdn.net/u012954706/article/details/82149431</src>
			<note>
				容器文件拷贝至本地	docker cp  68605b1872e5:/etc/nginx/nginx.conf /Users/yuey/Desktop/docker/nginx_conf
				本地文件拷贝至容器	docker cp /Users/yuey/Desktop/docker/nginx_conf 68605b1872e5:/etc/nginx/
				
				docker ps
				docker restart 68605b1872e5
			</note>
			
			
		</docker>
		

		<java_note id="05">
			<title>在Java语言中使用abstract class来定义抽象类</title>
			<src>http://www.runoob.com/java/java-abstraction.html</src>
			<body>
				/*java 不支持多继承，如果希望一个类能同时继承两个以上的父类
				 *可以使用接口(interface)来实现多继承的效果
				 *接口是一种纯粹的 抽象类，只 包含了抽象方法和常量的定义
				 *抽象方法必须由其子类来实现implement，才能赋予新的功能
				 *子类实现接口，使用implement关键字，可以实现多个接口，接口名之间用逗号隔空
				 *
				 *
				 *接口与抽象类的区别：
				 *1.接口是纯粹的抽象类，接口中所有 的方法都是抽象的(只有声明，没有定义)，而抽象类允许包含有定义的方法
				 *2.子类实现  接口用implement， 继承  抽象类用extends关键字
				 *3.子类可以  实现 多个接口，但只能继承一个抽象类
				 *4.一个子类如果实现了一个接口，就必须重写这个接口里所有的方法；
				 *	抽象类的子类可以不重写抽象父类里的所有方法，但这个子类会自然成为抽象类
				 */

				 <note>Employee是一个抽象类，因此在代码中无法这样：Employee e = new Employee();  无法实例化出来一个实例对象，抽象类可以被继承extends
						: public class Salary extends Employee{ ... }
						然后通过抽象类内部的方法，子类调用来进行
				 </note>
			</body>

			<title>java bean</title>
			<body>
				javabean  重用性
				1、类内private封装私有属性


				2、访问私有属性需要public方法

				属性的修改器 setXxx
				属性的访问器 getXxx 若某个属性只有单个方法，则是为只读/只写

				范例：personBean
				属性：name,sex,age,married
			<link title="什么是JavaBean" src="https://www.cnblogs.com/zterry/p/6863388.html"/>
			</body>

			<title>JAVA中extends 与implements区别</title>
			<src>https://www.cnblogs.com/hnrainll/archive/2011/10/11/2207773.html</src>
			<note>
				extends用于类的继承，一个java类只可以继承一个类
				implements用于实现接口，可以实现多个接口

				抽象类可以被继承(extends)，接口可以被实现(implements)，但是抽象类不能被实现（implements），接口也能被继承（extends）--接口扩充，这样一来继承了一个接口的类就有了两个接口的方法
				接口可以继承接口，类只能实现接口。

			</note>
			<body>
				public inerface Runner						<!--Runner接口-->
				{
				int ID = 1;
				void run ();
				}
				interface Animal extends Runner				<!--Animal接口 继承 Runner接口 （Animal接口有ID run() breathe()）-->
				{
				void breathe ();
				}
				class Fish implements Animal				<!--Fish类 实现 Animal接口（Fish有Animal接口（ID run() breathe()）-->
				{
				public void run ()
				{
				System.out.println(&quot; fish is swimming&quot; );
				}
				public void breather()
				{
				System.out.println(&quot; fish is bubbing&quot; );
				}
				}
				abstract LandAnimal implements Animal		<!--抽象LandAnimal类 实现 Animal接口（LandAnimal类有Animal接口（ID run() breathe()）-->
				{

				public void breather ()
				{
				System.out.println(&quot; LandAnimal is breathing&quot; );
				}
				}
				class Student extends Person implements Runner
				{
				......
				public void run ()
					{
						System.out.println(&quot; the student is running&quot; );
					}
				......
				}
				interface Flyer
				{
				void fly ();
				}
				class Bird implements Runner , Flyer
				{
				public void run ()
				{
					System.out.println(&quot; the bird is running&quot; );
				}
				public void fly ()
				{
					System.out.println(&quot; the bird is flying&quot; );
				}
				}
				class TestFish
				{
				public static void main (String args[])
				{
					Fish f = new Fish();
					int j = 0;
					j = Runner.ID;
					j = f.ID;
				}

				}
			</body>

		</java_note>

		<study_link id="06">
			<link value="易百教程" src="https://www.yiibai.com/"/>
			<link value="" src=""/>
			<link value="spring官方下载地址" src="https://repo.spring.io/libs-release-local/org/springframework/spring/"/>
		</study_link>


		<spring_note id="07">
			<title>Spring读取配置文件的几种方式</title>
			<src>https://www.cnblogs.com/tfgzs/p/3932827.html</src>
			<body>
				import org.springframework.core.io.ClassPathResource;
				import org.springframework.core.io.FileSystemResource;
			</body>

			<title>41. XML Schema-based configuration</title>
			<src>spring-framework-4.3.0.RELEASE/docs/spring-framework-reference/html/xsd-configuration.html</src>
			<note>spring框架自带的文档说明网页</note>
		</spring_note>
	</project_note>
</Document>